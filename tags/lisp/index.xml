<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lisp on Shreyas Ragavan</title>
    <link>https://shrysr.github.io/tags/lisp/</link>
    <description>Recent content in lisp on Shreyas Ragavan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 17 Feb 2019 08:02:00 -0700</lastBuildDate>
    
	<atom:link href="https://shrysr.github.io/tags/lisp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Literate Org-mode configuration for Emacs is liberating</title>
      <link>https://shrysr.github.io/post/d16caa34-c2e2-439b-894f-d95be5708160/</link>
      <pubDate>Sun, 17 Feb 2019 08:02:00 -0700</pubDate>
      
      <guid>https://shrysr.github.io/post/d16caa34-c2e2-439b-894f-d95be5708160/</guid>
      <description>TLDR: Check out the Docs section for my Emacs config in Org-mode
 The literate programming paradigm, as conceived by Donald Knuth, represents a move away from writing programs in the manner and order imposed by the computer, and instead enables programmers to develop programs in the order demanded by the logic and flow of their thoughts. Literate programs are written as an uninterrupted exposition of logic in an ordinary human language, much like the text of an essay, in which macros are included to hide abstractions and traditional source code.</description>
    </item>
    
    <item>
      <title>Leverage recorded macros to learn elisp and hack together workflows in Emacs</title>
      <link>https://shrysr.github.io/post/7b7b94ca-2d77-4814-8cae-c9e95d3f8bc4/</link>
      <pubDate>Sat, 02 Feb 2019 10:16:00 -0700</pubDate>
      
      <guid>https://shrysr.github.io/post/7b7b94ca-2d77-4814-8cae-c9e95d3f8bc4/</guid>
      <description>The primary power of Emacs is that you can create customised workflows to suit your needs. However, lisp is probably not a language that many learn as a typical requirement in the academic systems, perhaps even for a software engineer.
How would one then start customisting Emacs? One way would be to hunt for snippets from forums like reddit and stack overflow, and customise them.
Another easy way to learn a programming language, especially one that is intrinsic to a software is to record macros and edit these macros.</description>
    </item>
    
    <item>
      <title>&#39;Archaic&#39; text based email clients rock!</title>
      <link>https://shrysr.github.io/post/e4e7ebb1-4c0c-41d6-b7e4-1c1c09e48c80/</link>
      <pubDate>Sat, 13 Jul 2019 19:33:00 -0600</pubDate>
      
      <guid>https://shrysr.github.io/post/e4e7ebb1-4c0c-41d6-b7e4-1c1c09e48c80/</guid>
      <description>Table of Contents  TLDR - for the busy folks  Goals: Summary:  Multiple email accounts. Lack of a unified interface. Creating sync channels via mbsync Text based email client! Speed + simplicity Why mu4e rocks [for me] - the perks Quirks Multiple levels of filters are still necessary. Takeaways Links and References   
This dev.to blog post inspired me to complete this languishing draft of my current email setup, and the benefits I&amp;rsquo;ve gained from using a text based email client in Emacs.</description>
    </item>
    
  </channel>
</rss>